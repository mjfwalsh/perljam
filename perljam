#!/usr/bin/perl -w

# core modules
use strict;
use File::Copy;
use Cwd qw{getcwd abs_path};
use IPC::Open3;
use File::Temp ();

# other modules
use File::Which ();

# In Windows the open3 command does not do CRLF to LF transition like open does
$/ = "\r\n" if $^O eq 'MSWin32';

# Load Win32 on windows systems
BEGIN { require Win32 if $^O eq 'MSWin32'; }

# setup some control variables
my $version = '0.0';
my %pdf = ();
my @input_files;

# default values
my %opt = (
batch => 0,
crop => 0,
tidy => 1,
keepinfo => 0,
checkfiles => 0,
suffix => 'perljam',
preamble => '',
out => getcwd(), # output to current working directory by default
paper => 'a4paper',
verbose => 0,
landscape => 0,
twoside => 0,
);

# default binary names depend on operating system
if($^O =~ /mswin32/i) {
	$opt{ghostscript} = 'gswin32c.exe';
	$opt{pdflatex} = 'pdflatex.exe';
	$opt{pdfinfo} = 'pdfinfo.exe';
	$opt{kpsewhich} = 'kpsewhich.exe';
	$opt{file} = 'file.exe';
} else {
	$opt{ghostscript} = 'gs';
	$opt{pdflatex} = 'pdflatex';
	$opt{pdfinfo} = 'pdfinfo';
	$opt{kpsewhich} = 'kpsewhich';
	$opt{file} = 'file';
}

############################################################
### Process command line options and configuration files ###
############################################################

print "Processing command args..." if $opt{verbose};

my $param_guide = parse_param_index(
qw{help|h! version|v! out|outfile|o},

# programs
qw{ghostscript|gs pdflatex pdfinfo kpsewhich file},

# pdf info
qw{author|pdfauthor keywords|pdfkeywords subject|pdfsubject title|pdftitle},

# pairs
qw{quiet|q!verbose verbose! portrait!landscape landscape! oneside!twoside twoside!},

# package options
qw{final! draft! enable-survey!},

# paper
qw{paper|papersize a4paper=v:paper a5paper=v:paper b5paper=v:paper
letterpaper|letter=v:paper executivepaper|executive=v:paper legalpaper|legal=v:paper
a0paper=v:paper a1paper=v:paper a2paper=v:paper a3paper=v:paper a6paper=v:paper
b0paper=v:paper b1paper=v:paper b2paper=v:paper b3paper=v:paper b4paper=v:paper
b6paper=v:paper},

# misc
qw{batch! checkfiles! keepinfo! tidy! vanilla! crop!
configpath preamble. suffix pagecolor configfile margin},
);

my $args = process_args_from_cmd_line($param_guide);

if($args->{help}) {
	print_help();
	exit;
}

if($args->{version}) {
	print "\n" if $opt{verbose};
	print "Version: $version\n";
	exit;
}

# check vanilla
if(!$args->{vanilla} && defined $ENV{PERLJAMCONFIG}) {
	my @configfiles = grep { -f } split(/:/, $ENV{PERLJAMCONFIGFILE});
	if($#configfiles > -1) {
		my $file_args = process_args_from_file($param_guide, @configfiles);
		# now merge hashes: cmd_args wallop file_args
		$args = [%$file_args, %$args];
	}
}

# avoid having to write paper after known paper types
if($args->{paper} && $args->{paper} =~ m/^([a-zA-Z][0-9]|letter|executive|legal)$/) {
	$args->{paper} .= 'paper';
}

# split into two groups
while(my($key, $value) = each %$args) {
	if(!defined $value) { $value = ''; }

	if(defined $param_guide->{$key}) {
		$opt{$key} = $value;
	} else {
		$key =~ s/2$/\*/;
		$pdf{$key} = $value;
	}
}

print "done\n" if $opt{verbose};

#########################################
### Process input files and selectors ###
#########################################

print "Processing input files..." if $opt{verbose};

while(my $arg = shift @ARGV) {
	if(-f $arg || -l $arg) {
		# get absolute path
		$arg = safe_abs_path($arg);
	} elsif($arg eq 'stdin' || $arg eq '-') {
		# nothing
	} else {
		die "\n$arg does not exist\n";
	}

	my $file = {source => $arg};

	if($#ARGV > -1 && $ARGV[0] =~ m/^[,0-9\{\}\-last]+$/ && !-e $ARGV[0]) {
		$file->{pages} = shift @ARGV;
	}

	push @input_files, $file;
}
die "\nNo input files! Quitting\n" if $#input_files < 0;

if(!$opt{batch} && $#input_files > 0 && $opt{keepinfo}) {
	die "\nWe can't keep info for more than one pdf file when not in batch mode\n";
}

if($opt{batch} && $#input_files == 0) {
	# Not much point in batch mode with only one input file
	$opt{batch} = 0;
}

print "done\n" if $opt{verbose};

#########################################
### Check output file/location        ###
#########################################

print "Processing files and selectors..." if $opt{verbose};

$opt{out} = safe_abs_path($opt{out});
if(-d $opt{out}) {
	die "\nCannot write to output directory: $opt{out}\n" if !-w $opt{out};
} elsif(-e $opt{out}) {
	die "\nOutput file already exists\n";
} elsif($opt{batch} || $opt{out} =~ m|/$|) {
	mkdir $opt{out} || die "Failed to create output directory: $opt{out}\n";
} elsif($opt{out} =~ m|^(.*/)([^/]+)$| && -d $1) {
	die "\nCannot write to output location: $1\n" if !-w $1;
} else {
	die "\nFailed to understand --out|-o\n";
}

print "done\n" if $opt{verbose};

############################################################################
### Get full paths for executables or check that they are in the path    ###
### Die if we don't have pdflatex and kpsewhich as we need these to work ###
############################################################################

print "Checking executables..." if $opt{verbose};

foreach my $exec (qw{ghostscript pdflatex pdfinfo kpsewhich file}) {
	if(-f $opt{$exec}) {
		$opt{$exec} = safe_abs_path($opt{$exec});
	} else {
		$opt{$exec} = check_path($opt{$exec});
	}
}

die "\nFailed to find pdflatex in path!\n" unless $opt{pdflatex};
die "\nFailed to find kpsewhich in path!\n" unless $opt{kpsewhich};

print "done\n" if $opt{verbose};

#######################################################
### Check we have required TeX packages and provide ###
### useful warnings for optionally needed packages  ###
#######################################################

print "Checking TeX packages..." if $opt{verbose};

# now have a look around for some TeX packages
my %texpackages = kpsewhich('pdfpages.sty', 'eso-pic.sty', 'everyshi.sty', 'hyperref.sty', 'geometry.sty');

# we need these three to function
die "\nCan't find required TeX package pdfpages!\n" unless $texpackages{'pdfpages.sty'};
die "\nCan't find required TeX package eso-pic!\n" unless $texpackages{'eso-pic.sty'};
die "\nCan't find required TeX package everyshi!\n" unless $texpackages{'everyshi.sty'};

# print some helpful error messages if prerequisites are missing
my @prerequisites;

# keepinfo
if($opt{keepinfo} && !$opt{pdfinfo}) {
	push @prerequisites, "Cannot keep pdf info without pdfinfo!";
}

# hyperref
if(defined $opt{title} || defined $opt{author} || defined $opt{subject} || defined $opt{keywords}) {
	push @prerequisites, "Cannot set pdf properties without the TeX hyperref package!" if !$texpackages{'hyperref.sty'};
} elsif(!$opt{keepinfo}) {
	# if we're not --keepinfo and haven't set any pdf properties disable hyperref
	$texpackages{'hyperref.sty'} = 0;
}

# crop
if($opt{crop} && !$opt{ghostscript}) {
	push @prerequisites, "Cannot crop without ghostscript!";
}

# checkfiles
if($opt{checkfiles} && !$opt{file}) {
	push @prerequisites, "Cannot checkfiles without file command!";
}

# paper
if(!$texpackages{'geometry.sty'} && $opt{paper} !~ /^(a4|a5|b5|letter|executive|legal)paper$/) {
	# need geometry package
	push @prerequisites, "We need the TeX geometry package for the paper size $opt{paper}!";
}


if($#prerequisites > -1) {
	print "\n";
	push @prerequisites, "Check the command is in your path!";
	print join "\n", @prerequisites;
	print "\n";
	exit;
}

print "done\n" if $opt{verbose};

#######################
### Process margins ###
#######################

my @margins;
if($opt{margin}) {
	@margins = split(/ +/, $opt{margin});

	unless($#margins == 0 || $#margins == 1 || $#margins == 3) {
		die "--margin must have 1, 2 or 4 measurements\n";
	}

	if($opt{crop}) {
		# Ghostscript uses post script points (1/72 of an inch) while tex uses US points (1/72.27 of an inch)
		my %units = (mm => 2.83464566929134, pc => 11.9551681195517,
			cm => 28.3464566929134, in => 72, pt => 0.99626400996264, bp => 1);
		$units{''} = $units{'pt'};

		foreach my $margin (@margins) {
			if($margin =~ m/^(-?[0-9\.]+)(mm|pc|cm|in|pt|bp|)$/) {
				$margin = int(($1 * $units{$2}) + 0.5);
			} else {
				die "Malformed --margin param\n";
			}
		}
	} else {
		foreach my $margin (@margins) {
			if($margin =~ m/^(-?[0-9\.]+)(mm|pc|cm|in|pt|bp|)$/) {
				my $unit = $2 eq '' ? 'pt' : $2;
				$margin = ($1 * -1) . $unit;
			} else {
				die "Malformed --margin param\n";
			}
		}
	}

	if($#margins == 0) {
		@margins = ($margins[0], $margins[0], $margins[0], $margins[0]);
	} elsif($#margins == 1) {
		@margins = ($margins[0], $margins[1], $margins[0], $margins[1]);
	}

	if(!$opt{crop}) {
		$pdf{trim} = join ' ', @margins;
	}
} else {
	@margins = (0, 0, 0, 0);
}

###############################################################
### Create a temporary directory for processing TeX files   ###
###############################################################

my $tmpdir;
if(defined $opt{tempfiledir}) {
	$opt{tempfiledir} = safe_abs_path($opt{tempfiledir});
	$tmpdir = File::Temp->newdir( 'perljam-XXXXX', DIR => $opt{tempfiledir}, CLEANUP => $opt{tidy});
} else {
	$tmpdir = File::Temp->newdir( 'perljam-XXXXX', TMPDIR => 1, CLEANUP => $opt{tidy});
}

if(!$opt{tidy} || $opt{verbose}) {
	print "Temporary directory for this job is $tmpdir\n";
}

###########################################################################
### Process pdf files, determine bounding box for cropping if desired   ###
###########################################################################

my $counter = 1;
my %output_filenames = ();
for my $file (@input_files) {
	if(!defined $file->{pages}) {
		$file->{pages} = '-';
	}

	if($file->{source} eq 'stdin') {
		$file->{texname} = "input.pdf";
		my $temp_file = "$tmpdir/input.pdf";

		open (REDIR, ">$temp_file") || die "Failed to create temp file: $temp_file\n";

		# avoid crlf to lf translation on windows
		if($^O eq 'MSWin32') {
			binmode STDIN;
			binmode REDIR;
		}

		print REDIR <STDIN>;
		close REDIR;
	} elsif($^O eq 'MSWin32') {
		# use special windows short names with forward slashes to avoid complicated
		# filename escaping on windows systems
		# $^O eq 'MSWin32' on 64 bit systems

		my $f = Win32::GetShortPathName($file->{source});
		$f =~ s|\\|/|g;

		$file->{texname} = '\detokenize{' . $f . '}';
		if($opt{batch}) {
			$file->{tmpdir} = $tmpdir . "/file$counter";

			# create tmpdir
			mkdir $file->{tmpdir} || die "Failed to create temporary directory: $file->{tmpdir}\n";
		}
	} else {
		# create temporary symbolic link to avoid complicated
		# filename escaping on unix/linux/mac systems
		my $link_file;
		if($opt{batch}) {
			$link_file = $tmpdir . "/file$counter/input.pdf";
			$file->{tmpdir} = $tmpdir . "/file$counter";
			$file->{texname} = 'input.pdf';

			# create tmpdir now before link
			mkdir $file->{tmpdir} || die "Failed to create temporary directory: $file->{tmpdir}\n";
		} else {
			$link_file = $tmpdir . "/input$counter.pdf";
			$file->{texname} = "input$counter.pdf";
		}

		symlink ($file->{source}, $link_file) || die "Failed to create link file: $link_file\n";
	}
	$counter++;

	if($opt{keepinfo}) {
		my %pdfinfo;
		open3(0, \*PDFINFO, 0, $opt{pdfinfo}, $file->{source});
		while(my $line = <PDFINFO>) {
			next unless $line =~ m/^([^:]*): *(.+)/;
			$pdfinfo{lc $1} = $2;
		}
		close PDFINFO;

		if($pdfinfo{'pages'} =~ /^[0-9]+$/) {
			$file->{pagecount} = $pdfinfo{'pages'};
		} else {
			die "Pdfinfo failed!\n";
		}

		if($pdfinfo{'page size'} =~ /^([0-9\.]+) x ([0-9\.]+) pts/) {
			$file->{width} = $1;
			$file->{height} = $2;
		}

		foreach my $x (qw{title author subject keywords}) {
			if(defined $pdfinfo{$x}) {
				$file->{$x} = $pdfinfo{$x};
			}
		}
	}

	if($opt{crop}) {
		$file->{viewport} = do_crop($file);
	}
}

####################
### Generate TeX ###
####################

my $tex_file_content = "\\batchmode\n";

my @document_options = ($opt{paper});
push @document_options, 'landscape' if $opt{landscape};
push @document_options, 'twoside' if $opt{twoside};
$tex_file_content .= "\\documentclass[" . join(',', @document_options) . "]{article}\n";

if($opt{pagecolor}) {
	$tex_file_content .= '\\usepackage{color} \\definecolor{bgclr}{RGB}{';
	$tex_file_content .= $opt{pagecolor};
	$tex_file_content .=  '} \\pagecolor{bgclr}' . "\n";
}

if($texpackages{'geometry.sty'}) {
	$tex_file_content .= "\\usepackage[$opt{paper}]{geometry}\n";
}

$tex_file_content .= "\\usepackage[utf8]{inputenc}\n";

if($texpackages{'hyperref.sty'}) {
	$tex_file_content .= "\\usepackage{hyperref}\n";

	foreach my $p (qw|title author subject keywords|) {
		if(defined $opt{$p}) {
			$tex_file_content .= '\\hypersetup{pdf' . $p . '={' . $opt{$p} . "}}\n";
		}
	}
}

# package options
my $tex_file_content2 = "\\usepackage{pdfpages}\n";

# print preamble if we have any
$tex_file_content2 .= $opt{preamble} . "\n";

# don't use \includepdfset as not all options can be included that way
my @global_options = ();
while(my($k, $v) = each %pdf) {
	if(defined $v && length $v > 0) {
		push(@global_options, $k . '={' . $v . '}');
	}
}

$tex_file_content2 .= "\\begin{document}\n";

my $start_cwd = getcwd(); # save current directory
if($opt{batch}) {
	print "Batch mode..\n" if $opt{verbose};
	foreach my $file (@input_files) {
		chdir $file->{tmpdir};

		open TEMPLATE, '>a.tex' || die "Failed to create tex file: " .  getcwd() . "/a.tex\n";
		print TEMPLATE $tex_file_content;

		if($texpackages{'hyperref.sty'}) {
			print TEMPLATE compile_pdf_info(\%opt, $file);
		}

		print TEMPLATE $tex_file_content2;
		print TEMPLATE includepdf($file, 'pages', 'viewport');
		print TEMPLATE "\\end{document}\n";
		close TEMPLATE;

		callpdflatex(); # works on current directory

		my $pdf_name = get_pdf_basename($file->{source});
		my $o = get_unique_filename("$opt{out}/$pdf_name", "$opt{suffix}.pdf");

		move_output($o);
	}
} else {
	chdir $tmpdir;

	open TEMPLATE, '>a.tex' || die "Failed to create tex file: " .  getcwd() . "/a.tex\n";
	print TEMPLATE $tex_file_content;

	if($texpackages{'hyperref.sty'}) {
		print TEMPLATE compile_pdf_info(\%opt, $input_files[0]);
	}

	print TEMPLATE $tex_file_content2;
	foreach my $file (@input_files) {
		print TEMPLATE  includepdf($file, 'pages', 'viewport');
	}
	print TEMPLATE "\\end{document}\n";
	close TEMPLATE;

	callpdflatex(); # works on current directory

	my $pdf_name;
	my $o;
	if(-d $opt{out}) {
		if($#input_files == 0) {
			$pdf_name = get_pdf_basename($input_files[0]{source});
		} else {
			$pdf_name = 'output';
		}
		$o = get_unique_filename("$opt{out}/$pdf_name", "$opt{suffix}.pdf");
	} else {
		$o = $opt{out};
	}

	move_output($o);
}
chdir $start_cwd;

#########################
###    Subroutines    ###
#########################

# runs kpsewhich commmand, return true/false list of installed Tex packages
sub kpsewhich {
	my %texpackages;
	foreach my $k (@_) {
		$texpackages{$k} = 0;
	}

	open3(0, \*CMD, \*CMD,  $opt{kpsewhich}, keys %texpackages);
	while(my $file = <CMD>) {
		chomp $file;
		$file =~ s|^.*/||;
		if(exists $texpackages{$file}) {
			$texpackages{$file} = 1;
		}
	}
	close CMD;

	return %texpackages;
}

# Documentation
sub print_help {
	print "I should really write some documentations sometime...\n";
}

# get a unique filename for output - loops until it finds one
sub get_unique_filename {
	my ($prefix, $suffix) = @_;
	my $o;
	my $i = 0;
	my $h = '.';

	do {
		$o = "$prefix$h$suffix";
		$i++;
		$h = ".$i.";
	} while -f $o;
	return $o;
}

sub parse_param_index {
	# parse param types from array
	my %param_guide;
	while(my $k = shift @_) {
		my $h = {};
		if($k =~ s/\!$//) {
			$h->{type} = 'boolean';
		} elsif($k =~ s/\!([a-z0-9]+)$//) {
			$h->{type} = 'boolean';
			$h->{invert} = $1;
		} elsif($k =~ s/\=v\:(.+)$//) {
			$h->{type} = 'value';
			$h->{assoc} = $1;
		} elsif($k =~ s/\.$//) {
			$h->{type} = 'concat';
		} else {
			$h->{type} = 'string';
		}

		my @names = split (/\|/, $k);
		$h->{name} = $names[0];

		foreach my $pk (@names) {
			$param_guide{$pk} = $h;
		}
	}

	return \%param_guide;
}

sub process_args_from_cmd_line {
	my $param_guide = shift;

	# process command line args
	my %params_from_cmd;
	my @remainder;
	my $awaiting_value;
	while (my $arg = shift @ARGV) {
		if($arg eq '--') {
			last;
		} elsif($arg =~ m/^--(.+)$/ || $arg =~ /^-([a-zA-Z])$/) {
			$awaiting_value = undef; # reset

			my $key = lc $1;
			my $value;

			my $ref = $key;
			my $boolean_value = $ref =~ s/^no-// ? 0 : 1;

			if(defined $param_guide->{$ref}) {
				$key = $param_guide->{$ref}{name};

				if($param_guide->{$ref}{type} eq 'value') {
					# transform --a4paper to --paper a4
					$key = $param_guide->{$ref}{assoc};
					$value = $param_guide->{$ref}{name};
				} elsif($param_guide->{$ref}{type} eq 'boolean') {
					$value = $boolean_value;

					# grab next value (if any)
					if(my $next = shift @ARGV) {
						if($next =~ /^(false|0)$/) {
							$value = $value ? 0 : 1;
						} elsif($next =~ /^(true|1)$/) {
							# nothing to do here, are true by default
						} else {
							unshift @ARGV, $next;
						}
					}

					# deal with inversions eg (quiet to verbose)
					if(defined $param_guide->{$ref}{invert}) {
						$key = $param_guide->{$ref}{invert};
						$value = $value ? 0 : 1;
					}
				}
			}

			if(!defined $value) {
				$awaiting_value = $key;
			}

			$params_from_cmd{$key} = $value;
		} elsif (defined $awaiting_value) {
			if(defined $param_guide->{$awaiting_value}{type} && $param_guide->{$awaiting_value}{type} eq 'concat' && defined $params_from_cmd{$awaiting_value}) {
				$params_from_cmd{$awaiting_value} .= "\n" . $arg;
			} else {
				$params_from_cmd{$awaiting_value} = $arg;
			}
			$awaiting_value = undef;
		} else {
			push @remainder, $arg;
		}
	}

	# unshift unused back onto ARGV
	unshift @ARGV, @remainder;

	return \%params_from_cmd;
}

sub process_args_from_file {
	my $param_guide = shift;
	my @configfiles = @_;

	# now process configuration file
	my %params_from_file = ();
	while(my $configfile = shift @configfiles) {
		open CONFIG, '<', $configfile;
		while(my $line = <CONFIG>) {
			chomp $line;
			$line =~ s|#.*$||; # remove comments
			$line =~ s|^[\t ]*(.+)[\t ]*$|$1|; # trim whitespace
			next if $line =~ m|^[\t ]*$|;

			$line =~ m/^([a-zA-Z0-9\-]+)(.*$|$)/ || next;

			my $key = lc $1;
			my $ref = $key;

			my $value = $2;
			$value =~ s/^ *[=:]//;
			$value =~ s|^[\t ]*||;
			$value =~ s/^(['"])(.*)\g1$/$2/g; # strip quotes

			my $boolean_value = ($ref =~ s/^no-// ? 0 : 1);

			if(defined $param_guide->{$ref}) {
				$key = $param_guide->{$ref}{name};
				if($param_guide->{$ref}{type} eq 'value') {
					$key = $param_guide->{$ref}{assoc};
					$value = $param_guide->{$ref}{name};
				} elsif($param_guide->{$ref}{type} eq 'boolean') {
					if($value =~ /^(false|0)$/) {
						$value = $boolean_value ? 0 : 1;
					}

					# deal with inversions eg (quiet to verbose)
					if(defined $param_guide->{$ref}{invert}) {
						$key = $param_guide->{$ref}{invert};
						$value = $value ? 0 : 1;
					}
				} elsif($param_guide->{$ref}{type} eq 'concat' && defined $params_from_file{$key}) {
					$params_from_file{$key} .= "\n" . $value;
					next;
				}
			}

			$params_from_file{$key} = $value;
		}
		close CONFIG;
	}

	return \%params_from_file;
}

sub includepdf {
	my $fileobj = shift;
	my @keys = @_;

	my @file_options;
	foreach my $k (@keys) {
		if(defined $fileobj->{$k}) {
			if(length $fileobj->{$k} > 0) {
				push @file_options, $k . '={' . $fileobj->{$k} . '}';
			} else {
				push @file_options, $k;
			}
		}
	}
	return "\\includepdf[" . join(',', @global_options, @file_options) . ']{' . $fileobj->{texname} . "}\n";
}


sub callpdflatex {
	# this subroutine relies on the current working directory being correctly set
	print "Calling pdflatex..."  if $opt{verbose};

	open3(0, \*CMD, 0, $opt{pdflatex}, 'a.tex');
	open MSG, '>a.msg';
	print MSG <CMD>;
	close MSG;

	if(close CMD && -f 'a.pdf') {
		print "done\n" if $opt{verbose};
	} else {
		my $cwd = getcwd();
		die "Pdflatex failed in $cwd\n";
	}
}

sub move_output {
	my $o = shift;

	# checkfiles
	if($opt{checkfiles}) {
		my $output;
		# run file command on output
		open3(0, \*CMD, 0, $opt{file}, '-b', 'a.pdf');
		$output = <CMD>;
		close CMD;
		chomp $output;

		if($output !~ m/^PDF document/) {
			die "Output not verified as a PDF document: '" . getcwd() . "/a.pdf'!\n";
		}
	}

	if(move('a.pdf', $o)) {
		print "Created output file: $o\n" if $opt{verbose};
	} else {
		die "Cannot copy '" . getcwd() . "/a.pdf' to '$o'!\n";
	}
}

sub check_path {
	my $exec = shift;

	my $path = File::Which::which($exec); # scalar context

	return 0 if !$path;

	return $exec;
}

sub do_crop {
	my $file = shift;

	# parse selector
	my $selector = $file->{pages};
	$selector =~ s/last/inf/;
	$selector =~ s/(^|,)-/${1}1-/g;
	$selector =~ s/-(,|$)/-inf$1/g;
	$selector =~ s/(^|,)\{\}/$1/g;

	# get first and last pages
	my ($first, $last) = ('inf', 0);
	my @parts = split /[-,]/, $selector;

	foreach my $p (@parts) {
		if($p =~ /^([0-9]+|inf)$/ && $p > 0) {
			if($p < $first) { $first = $p; }
			if($p > $last) { $last = $p; }
		} else {
			die "\nBad selector: $file->{pages}\n";
		}
	}

	# prepare ghostscript command
	my @gs_cmdpipe = ($opt{ghostscript}, '-sDEVICE=bbox', '-dBATCH', '-dNOPAUSE');
	if($first > 1) {
		push @gs_cmdpipe, '-dFirstPage=' . $first;
	}
	if($last ne 'inf') {
		push @gs_cmdpipe, '-dLastPage='. $last;
	}
	push @gs_cmdpipe, '-c', 'save', 'pop', '-f', $file->{source};

	# run ghostscript
	open3(0, \*CMD, \*CMD, @gs_cmdpipe) or die "Cannot call ghostscript!\n";

	print "Running ghostscript for crop..." if $opt{verbose};
	my @bb;
	$bb[ $first - 1 ] = (); # dummy to align index with page numbers
	while (my $line = <CMD>) {
		if($line =~ /^%%HiResBoundingBox: *([0-9\.]+) ([0-9\.]+) ([0-9\.]+) ([0-9\.]+)/) {
			push @bb, [$1, $2, $3, $4];
		}
	}
	close(CMD);

	# last page
	if($last eq 'inf' && !defined $file->{pagecount}) {
		$file->{pagecount} = $#bb;
	}

	# further selector parsing
	$selector =~ s/inf/$file->{pagecount}/;

	my %usedpages = ();
	foreach my $s (split /,/, $selector) {
		if($s =~ m/^[0-9]+$/) {
			$usedpages{$s} = 1;
		} elsif($s =~ m/^([0-9]+)-([0-9]+)$/) {
			if($1 < $2) {
				@usedpages{$1...$2} = ();
			} elsif($1 == $2) {
				$usedpages{$1} = 1;
			} else {
				@usedpages{$2...$1} = ();
			}
		} else {
			die "\nBad selector: $file->{pages}\n";
		}
	}
	my @usedpages = sort { $a <=> $b } keys %usedpages;

	#Calculate output dimensions
	my ($left, $top, $right, $bottom) = @{ $bb[shift @usedpages ] };
	foreach my $i (@usedpages) {
		if ($bb[$i][0] < $left)   { $left   = $bb[$i][0] }
		if ($bb[$i][1] < $top)    { $top    = $bb[$i][1] }
		if ($bb[$i][2] > $right)  { $right  = $bb[$i][2] }
		if ($bb[$i][3] > $bottom) { $bottom = $bb[$i][3] }
	}

	# adjust for margins
	$left   -= $margins[0];
	$top    -= $margins[1];
	$right  += $margins[2];
	$bottom += $margins[3];

	# pdfTex can't deal with decimal places
	$left   = int($left + 0.5);
	$top    = int($top + 0.5);
	$right  = int($right + 0.5);
	$bottom = int($bottom + 0.5);

	print "done\nOutput dimentions: ${left}bp ${top}bp ${right}bp ${bottom}bp\n" if $opt{verbose};

	return "${left}bp ${top}bp ${right}bp ${bottom}bp";
}

sub get_pdf_basename {
	my $f = shift;

	if($^O eq 'MSWin32') {
		$f = Win32::GetLongPathName($f);
		$f =~ s|\\|/|g;
	}

	$f =~ s|^.*/||;
	$f =~ s/\.pdf$//i;

	return $f;
}
sub safe_abs_path {
	my $p = shift;
	my $x = $p =~ s|[/\\]$||; # remove trailing slashes

	if($^O eq 'MSWin32') {
		# on windows Cwd::safe_abs_path fails on non-existent files
		$p = Win32::GetFullPathName($p);
		$p =~ s|\\|/|;
	} else {
		$p = abs_path($p);
	}

	if($x) {
		$p .= '/';
	}

	return $p;
}


sub compile_pdf_info {
	my $opt = shift;
	my $file = shift;

	my @pdfinfo = ();
	if($texpackages{'hyperref.sty'}) {
		foreach my $p (qw|title author subject keywords|) {
			if(defined $opt->{$p}) {
				push @pdfinfo, 'pdf' . $p . '={' . $opt->{$p} . '}';
			} elsif(defined $file->{$p}) {
				push @pdfinfo, 'pdf' . $p . '={' . $file->{$p} . '}';
			}
		}
	}

	my $ret = '';
	if($#pdfinfo > -1) {
		$ret .= "\\usepackage{hyperref}\n";
		$ret .= '\\hypersetup{';
		$ret .= join ',', @pdfinfo;
		$ret .= "}\n";
	}
	return $ret;
}

